#!/usr/bin/env python

# coding=utf-8
# pylint: disable=broad-except,unused-argument,line-too-long
# Copyright (c) 2016-2018, F5 Networks, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
This module reads OpenStack metadata from an attached configdrive,
creates TMSH and f5-declarative-onboarding artifacts from the
metadata, and then onboards the TMOS device.

The module must be enabled in the userdata YAML to perform any
onboarding artifact generation or onboarding.

#cloud-config
tmos_configdrive_openstack:
  enabled: True

This module will also look for YAML metadata which typically
is handled by the cc_ssh.py module:

#cloud-config
ssh_authorized_keys:
  - ssh-rsa [key]
  - ssh-rsa [key]

The standard cloud-init cc_ssh.py module alters SELinux
configurations which may not be compatible with TMOS

Additional attributes supported in the YAML declaration
include

rd_enabled - Route domain decoration support, defaults to True.
device_discovery_interface - implicitly define the TMOS configsync interface.
default_route_interface - implicitly defint the TMOS default route interface.
license_key - optional license key for AUTOMATIC license registration for the BIG-IQ 
node_type - optional BIG-IQ type, options are cm or dcd, default is cm

#cloud-config
bigiq_configdrive_openstack:
  enabled: True
  rd_enabled: False
  do_enabled: True
  device_discovery_interface: 1.1
  default_route_interface: 1.3
  license_key = DQIOC-XJSVIC-YXX-MAASBJL-BJUDPRL
  node_type = cm

"""
import json
import logging
import os
import subprocess
import time

from cloudinit import bigiq_onboard_utils

# constants
MODULE_NAME = 'bigiq_configdrive_openstack'

OUT_DIR = '/var/lib/cloud/' + MODULE_NAME
EXEC_DIR = '/opt/cloud/' + MODULE_NAME

TMSH_CMD_FILE_DIR = EXEC_DIR + '/initscripts/all'
POST_ONBOARD_CMD_FILE_DIR = EXEC_DIR + '/initscripts/post'
METADATA_FILE_DIR = '/opt/cloud/instance'

ANSIBLE_VAR_FILE = '/var/lib/cloud/ansible/onboard/onboard_vars.yml'
ANSIBLE_PLAYBOOK_DIR = '/var/lib/cloud/ansible/onboard'
ANSIBLE_PLAYBOOK = 'onboard.yml'

NETWORK_DATA_FILE = METADATA_FILE_DIR + '/network_data.json'
META_DATA_FILE = METADATA_FILE_DIR + '/meta_data.json'

LOG_FILE = '/var/log/f5-cloudinit.log'

ERROR = 'ERROR'
SUCCESS = 'SUCCESS'

bigiq_onboard_utils.touch_file(LOG_FILE)

LOG = logging.getLogger(MODULE_NAME)
LOG.setLevel(logging.DEBUG)
FORMATTER = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
LOGFILE = logging.FileHandler(LOG_FILE)
LOGFILE.setLevel(logging.DEBUG)
LOGFILE.setFormatter(FORMATTER)
LOG.addHandler(LOGFILE)

ONBOARD_COMPLETE_FLAG_FILE = OUT_DIR + '/ONBOARD_COMPLETE'
POST_ONBOARD_FLAG_FILE = OUT_DIR + '/POST_ONBOARD_COMPLETE'

DEFAULT_DNS_SERVERS = ['8.8.8.8', '8.8.4.4']
DEFAULT_NTP_SERVERS = ['0.pool.ntp.org', '1.pool.ntp.org']
DEFAULT_TIMEZONE = 'UTC'
DEFAULT_DEVICE_DISCOVERY_INTERFACE = 'mgmt'

REMOVE_METADATA_FILES = False

ONBOARD_TIMEOUT = 120

SYSCMDS = bigiq_onboard_utils.SYSCMDS

SYSDEVPREFIX = 'eth'


def metadata_dir_exists():
    """Ensures metadata copy directory exists"""
    if not os.path.isdir(METADATA_FILE_DIR):
        os.makedirs(METADATA_FILE_DIR)


def tmsh_cmd_dir_exists():
    """Ensures TMSH generated init script directory exists"""
    if not os.path.isdir(TMSH_CMD_FILE_DIR):
        os.makedirs(TMSH_CMD_FILE_DIR)
    if not os.path.isdir(POST_ONBOARD_CMD_FILE_DIR):
        os.makedirs(POST_ONBOARD_CMD_FILE_DIR)
    if not os.path.isdir(OUT_DIR):
        os.makedirs(OUT_DIR)


# inject discovered SSH keys, we don't use the ssh_keys cloud-init module
# because it uses SELinuxGuard, which we don't know will always be
# safe with TMOS versions
def inject_public_ssh_keys(keys):
    """Injects discovered and metadata supplied SSH keys into the root account"""
    LOG.debug('injecting root SSH keys')
    if not keys:
        keys = []
    if os.path.isfile(META_DATA_FILE):
        LOG.debug('Looking for SSH keys from OpenStack meta_data file', META_DATA_FILE)
        os_md = json.load(open(META_DATA_FILE))
        for k in os_md['keys']:
            LOG.debug('injecting %s key from OpenStack meta_data', key['name'])
            keys.append(k['data'])
    else:
        LOG.error("could not find OpenStack meta_data to inject SSH keys")
    try:
        bigiq_onboard_utils.inject_public_ssh_keys(keys)
    except Exception as err:
        LOG.error('exception in injecting SSH keys: %s', err)


def get_metadata():
    """Reads in OpenStack configdrive metadata into dictionaries"""
    LOG.debug('parsing metadata files')
    os_nmd, os_md = {}, {}
    if os.path.isfile(NETWORK_DATA_FILE):
        os_nmd = json.load(open(NETWORK_DATA_FILE))
    if os.path.isfile(META_DATA_FILE):
        os_md = json.load(open(META_DATA_FILE))
    return (os_nmd, os_md)


def resolve_resources(rd_enabled=True,
                      default_route_interface=None,
                      device_discovery_interface=None,
                      inject_routes=True,
                      dhcp_timeout=120):
    """Resolve the resource provisioning dataset from metadata"""
    (os_nmd, os_md) = get_metadata()
    if not (bool(os_nmd) or bool(os_md)):
        LOG.error('OpenStack metadata unavailable.. halting processing')
        return ({}, {}, {}, {})
    if default_route_interface:
        LOG.debug('default_route_interface %s requested',
                  default_route_interface)
    else:
        LOG.debug(
            'no default_route_interface designated, will attempt to select dynamically'
        )
    if not device_discovery_interface:
        device_discovery_interface = DEFAULT_DEVICE_DISCOVERY_INTERFACE
    LOG.debug('setting device_discovery_interface to %s',
              device_discovery_interface)
    device_discovery_address = None
    # supported TMOS network types
    ln_types = ['phy', 'bridge', 'ovs', 'vif', 'tap']
    n_types = ['ipv4', 'ipv6']
    m_l_id = m_ip = m_nm = m_gw = None
    m_l_mtu = 1500
    # resolved resources
    links, selfips, routes, services = {}, {}, {}, {}
    number_of_default_routes = 0
    forced_tmm_down = False
    # resolve L2 interfaces
    n_idx = 0
    for link in os_nmd['links']:
        if not link['mtu']:
            link['mtu'] = 1500
        if n_idx == 0:
            m_l_id = link['id']
            m_l_mtu = link['mtu']
            bigiq_onboard_utils.force_mgmt_mtu(m_l_mtu)
            n_idx += 1
            continue
        if link['type'] in ln_types:
            net_name = 'net_%s' % link['id']
            net_name = net_name.replace('-', '_')
            links[link['id']] = {
                'net_name': net_name,
                'mtu': link['mtu'],
                'interface': '1.%s' % n_idx,
                'route_domain': 0,
                'interface_index': n_idx,
                'segmentation_id': 4094 - n_idx,
                'tagged': False
            }
            n_idx += 1
    # resolve L2 virtual networks
    for link in os_nmd['links']:
        if link['type'] == 'vlan':
            if link['vlan_link'] not in links:
                LOG.warn("VLAN %s defined for unsupported link %s",
                         link['vlan_id'], link['vlan_link'])
            else:
                if links[link['vlan_link']]['interface_index'] == 0:
                    LOG.warn(
                        "VLAN tagging is not supported on management interface"
                    )
                else:
                    links[link['id']] = {
                        'net_name':
                        'vlan_%s' % link['vlan_id'],
                        'mtu':
                        links[link['vlan_link']]['mtu'],
                        'interface':
                        links[link['vlan_link']]['interface'],
                        'interface_index':
                        links[link['vlan_link']]['interface_index'],
                        'segmentation_id':
                        link['vlan_id'],
                        'tagged':
                        True
                    }
    for net in os_nmd['networks']:
        # resolve DHCP discovered attributes
        if net['type'] == 'ipv4_dhcp':
            if net['link'] == m_l_id:
                try:
                    bigiq_onboard_utils.wait_for_mgmt_dhcp()
                    mgmt_data = bigiq_onboard_utils.process_dhcp4_lease(
                        bigiq_onboard_utils.MGMT_DHCP_LEASE_FILE)
                    if 'fixed-address' in mgmt_data:
                        m_ip = mgmt_data['fixed-address']
                    if 'subnet-mask' in mgmt_data:
                        m_nm = mgmt_data['subnet-mask']
                    if 'routers' in mgmt_data:
                        m_gw = mgmt_data['routers']
                    if 'host-name' in mgmt_data:
                        services['hostname'] = mgmt_data['host-name']
                    if 'domain-name' in mgmt_data:
                        services['domainname'] = mgmt_data['domain-name']
                    if device_discovery_interface == DEFAULT_DEVICE_DISCOVERY_INTERFACE:
                        device_discovery_address = m_ip
                except Exception as err:
                    LOG.error(
                        'exception in processing mgmt DHCP lease file: %s',
                        err)
            else:
                if not forced_tmm_down:
                    bigiq_onboard_utils.force_tmm_down()
                    forced_tmm_down = True
                interface = "%s%d" % (SYSDEVPREFIX,
                                      links[net['link']]['interface_index'])
                s_ip = s_nm = s_gw = s_routes = None
                try:
                    if bigiq_onboard_utils.make_dhcp4_request(
                            interface, dhcp_timeout):
                        interface_data = bigiq_onboard_utils.process_dhcp4_lease(
                            interface)
                        if 'fixed-address' in interface_data:
                            s_ip = interface_data['fixed-address']
                        if 'subnet-mask' in interface_data:
                            s_nm = interface_data['subnet-mask']
                        if 'routers' in interface_data:
                            s_gw = interface_data['routers']
                        if 'classless-static-routes' in interface_data:
                            s_routes = interface_data[
                                'classless-static-routes']

                        use_rd_on_this_link = True
                        if net['link'] not in routes:
                            routes[net['link']] = []

                        # default gateway from DHCPv4
                        if s_gw and s_gw != m_gw:
                            route = {}
                            inject_route = True
                            route['use_rd'] = True
                            route['exclude'] = False
                            if default_route_interface == links[
                                    net['link']]['interface']:
                                LOG.debug(
                                    'default_route_interface discovered with DHCPv4 as interface: %s gw: %s',
                                    links[net['link']]['interface'], s_gw)
                                route['use_rd'] = False
                                number_of_default_routes += 1
                            if device_discovery_interface == links[
                                    net['link']]['interface']:
                                LOG.debug(
                                    'device_discovery_interface discovered with DHCPv4 as link: %s',
                                    net['link'])
                                device_discovery_address = s_ip
                                route['use_rd'] = False
                                if not default_route_interface == device_discovery_interface:
                                    inject_route = False
                            if (not default_route_interface) and (
                                    number_of_default_routes == 0
                                    and inject_route):
                                LOG.debug(
                                    'dynamically setting default_route_interface with DHCPv4 interface: %s gw: %s',
                                    links[net['link']]['interface'], s_gw)
                                route['use_rd'] = False
                                use_rd_on_this_link = False
                                number_of_default_routes += 1
                            route['route_name'] = net['link'] + '_default_gw'
                            route['network'] = '0.0.0.0'
                            route['netmask'] = '0.0.0.0'
                            route['gateway'] = s_gw
                            if inject_route and inject_routes:
                                routes[net['link']].append(route)
                        for route in bigiq_onboard_utils.process_dhcp4_routes(
                                s_routes):
                            route['use_rd'] = True
                            route['exclude'] = False
                            if default_route_interface == links[
                                    net['link']]['interface']:
                                route['use_rd'] = False
                            if device_discovery_interface == links[
                                    net['link']]['interface']:
                                route['use_rd'] = False
                            if not use_rd_on_this_link:
                                route['use_rd'] = False
                            if inject_routes:
                                routes[net['link']].append(route)
                        selfip_name = 'selfip_%s' % net['link']
                        selfip_name = selfip_name.replace('-', '_')
                        selfips[net['link']] = {
                            'selfip_name': selfip_name,
                            'net_name': links[net['link']]['net_name'],
                            'ip_address': s_ip,
                            'netmask': s_nm
                        }
                    else:
                        if default_route_interface == links[
                                net['link']]['interface']:
                            LOG.warn(
                                'the requested default_route_interface self IP could not be resolved'
                            )
                        if device_discovery_interface == links[
                                net['link']]['interface']:
                            LOG.warn(
                                'the requested device_discovery_interface self IP could not be resolved'
                            )
                except Exception as err:
                    LOG.error(
                        'exception processing DHCPv4 for interface %s - %s',
                        interface, err)
        elif net['type'] == 'ipv6_dhcp':
            LOG.warn(
                'Found IPv6_DHCP network. Since interface-mtu and route prefix delegation are not supported with DHCPv6 and TMOS, skipping.'
            )
        else:
            if net['link'] == m_l_id:
                m_ip = net['ip_address']
                m_nm = net['netmask']
                for route in net['routes']:
                    if route['network'] == '0.0.0.0' or route[
                            'network'] == '::':
                        m_gw = route['gateway']
                if device_discovery_interface == DEFAULT_DEVICE_DISCOVERY_INTERFACE:
                    device_discovery_address = m_ip
            else:
                # resolve statically configured attributes
                if net['type'] in n_types:
                    # resolve L3 routing information
                    for route in net['routes']:
                        if net['link'] in links:
                            if net['link'] not in routes:
                                routes[net['link']] = []
                            inject_route = True
                            route['use_rd'] = True
                            route['exclude'] = False
                            if route['network'] == '0.0.0.0' or route[
                                    'network'] == '::':
                                if route['gateway'] != m_gw:
                                    route['route_name'] = net['link'] + \
                                        '_default_gw'
                                    if default_route_interface == links[
                                            net['link']]['interface']:
                                        LOG.debug(
                                            'default_route_interface discovered as interface: %s gw: %s',
                                            links[net['link']]['interface'],
                                            route['gateway'])
                                        route['use_rd'] = False
                                        number_of_default_routes += 1
                                    if device_discovery_interface == links[
                                            net['link']]['interface']:
                                        LOG.debug(
                                            'device_discovery_interface discovered as interface: %s',
                                            links[net['link']]['interface'])
                                        route['use_rd'] = False
                                        if not default_route_interface == device_discovery_interface:
                                            inject_route = False
                                    if (not default_route_interface) and (
                                            number_of_default_routes == 0
                                            and inject_route):
                                        LOG.debug(
                                            'dynamically setting default_route_interface as interface: %s gw: %s',
                                            links[net['link']]['interface'],
                                            route['gateway'])
                                        route['use_rd'] = False
                                        number_of_default_routes += 1
                            route['route_name'] = "route_%s_%s" % (
                                route['network'], route['netmask'])
                            route['route_name'] = route['route_name'].replace(
                                '.', '_').replace(':', '_').replace('/', '_')
                            if inject_route and inject_routes:
                                routes[net['link']].append(route)
                    # resolve interface L3 information
                    if net['link'] in links:
                        selfip_name = 'selfip_%s' % net['link']
                        selfip_name = selfip_name.replace('-', '_')
                        selfips[net['link']] = {
                            'selfip_name': selfip_name,
                            'net_name': links[net['link']]['net_name'],
                            'ip_address': net['ip_address'],
                            'netmask': net['netmask']
                        }
                        if device_discovery_interface == links[
                                net['link']]['interface']:
                            device_discovery_address = net['ip_address']
    if rd_enabled:
        LOG.debug('decorating route domains')
        for n_link in routes:
            for route in routes[n_link]:
                if route['use_rd']:
                    r_dom = str(links[n_link]['segmentation_id'])
                    links[n_link]['route_domain'] = r_dom
                    if selfips[n_link]['ip_address'].find('%') < 0:
                        selfips[n_link]['ip_address'] = selfips[n_link][
                            'ip_address'] + '%' + r_dom
                    route['route_name'] = route['route_name'] + '_' + r_dom
                    route['network'] = route['network'] + '%' + r_dom
                    route['gateway'] = route['gateway'] + '%' + r_dom
    else:
        for n_link in routes:
            for route in routes[n_link]:
                if route['use_rd'] and (route['network'] == '0.0.0.0'
                                        or route['network'] == '::'):
                    LOG.warn(
                        'excluding default route on link %s because route domains disabled',
                        n_link)
                    route['exclude'] = True

    LOG.debug('resolving service resources')
    dns_services = []
    ntp_services = []
    if 'hostname' not in services:
        LOG.warn('forcing device hostname to: %s', os_md['name'])
        services['hostname'] = os_md['name']
    if 'domainname' not in services:
        LOG.warn('forcing device domainname to .local')
        services['domainname'] = 'local'
    declared_hostname = "%s.%s" % (services['hostname'],
                                   services['domainname'])
    if len(declared_hostname) > 64:
        max_hostname = 63 - len(services['domainname'])
        services['hostname'] = services['hostname'][0:max_hostname]
    for service in os_nmd['services']:
        if service['type'] == 'dns' and (
                bigiq_onboard_utils.is_v6(service['address'])
                or bigiq_onboard_utils.is_v4(service['address'])):
            LOG.debug('discovered DNS service configuration')
            dns_services.append(service['address'])
        if service['type'] == 'ntp' and (
                bigiq_onboard_utils.is_v6(service['address'])
                or bigiq_onboard_utils.is_v4(service['address'])):
            LOG.debug('discovered NTP service configuration')
            ntp_services.append(service['address'])
    if dns_services:
        services['dns_services'] = dns_services
    else:
        services['dns_services'] = DEFAULT_DNS_SERVERS
    if ntp_services:
        services['ntp_services'] = ntp_services
    else:
        services['ntp_services'] = DEFAULT_NTP_SERVERS

    if forced_tmm_down:
        bigiq_onboard_utils.start_tmm()
    return {
        'mgmt_link_id': m_l_id,
        'mgmt_address': m_ip,
        'mgmt_netmask': m_nm,
        'mgmt_gateway': m_gw,
        'mgmt_mtu': m_l_mtu,
        'device_discovery_interface': device_discovery_interface,
        'device_discovery_address': device_discovery_address,
        'default_route_interface': default_route_interface,
        'links': links,
        'selfips': selfips,
        'routes': routes,
        'services': services
    }


def create_mgmt_init_script(resources):
    """Create initialization scripts for the mgmt interface"""
    LOG.debug('writing out mgmt interface scripts')
    LOG.debug('mmgt ip %s/%s', resources['mgmt_address'],
              resources['mgmt_netmask'])
    if resources['mgmt_gateway']:
        LOG.debug('mmgt gw %s', resources['mgmt_gateway'])
    tmsh_cmd_dir_exists()
    mgmt_onboard_script = TMSH_CMD_FILE_DIR + '/001_mgmt_setup.sh'
    # write out management network configuration
    with open(mgmt_onboard_script, 'w') as mgmt_script:
        mgmt_script.write("#!/bin/bash\n")
        mgmt_script.write("%s 'starting mgmt network provisioning'\n" %
                          SYSCMDS['echo'])
        mgmt_script.write(
            "%s modify sys global-settings mgmt-dhcp disabled\n" %
            SYSCMDS['tmsh'])

        mgmt_script.write("sleep 5\n")
        mgmt_script.write("%s create sys management-ip %s/%s\n" %
                          (SYSCMDS['tmsh'], resources['mgmt_address'],
                           resources['mgmt_netmask']))
        if resources['mgmt_gateway']:
            mgmt_script.write(
                "%s create sys management-route default gateway %s\n" %
                (SYSCMDS['tmsh'], resources['mgmt_gateway']))
        mgmt_script.write("%s link set %s mtu %s\n" %
                          (SYSCMDS['ip'], bigiq_onboard_utils.MGMT_DEV_NAME,
                           resources['mgmt_mtu']))
        mgmt_script.write(
            "%s '%s link set %s %s' >> /config/startup\n" %
            (SYSCMDS['echo'], SYSCMDS['ip'], bigiq_onboard_utils.MGMT_DEV_NAME,
             resources['mgmt_mtu']))
        mgmt_script.write("%s 'mgmt interface configured: %s/%s'\n" %
                          (SYSCMDS['echo'], resources['mgmt_address'],
                           resources['mgmt_netmask']))


def create_tmm_net_init_script(resources):
    """Create the initialization script for TMM network interfaces"""
    LOG.debug('writing out non declarative network provisioning scripts')
    network_onboard_script = TMSH_CMD_FILE_DIR + '/002_network_setup.sh'
    with open(network_onboard_script, 'w') as net_script:
        net_script.write("#!/bin/bash\n")
        net_script.write("%s 'starting network provisioning'\n" %
                         SYSCMDS['echo'])
        # write out L2 network configuration
        for l_id in resources['links']:
            link = resources['links'][l_id]
            if l_id == resources['mgmt_link_id']:
                continue
            if not link['tagged']:
                net_script.write(
                    "%s create net vlan %s mtu %s interfaces replace-all-with { %s } tag %s\n"
                    % (SYSCMDS['tmsh'], link['net_name'], link['mtu'],
                       link['interface'], link['segmentation_id']))
            else:
                net_script.write(
                    "%s create net vlan %s mtu %s interfaces replace-all-with { %s { tagged } } tag %s\n"
                    % (SYSCMDS['tmsh'], link['net_name'], link['mtu'],
                       link['interface'], link['segmentation_id']))
            if link['route_domain'] > 0:
                net_script.write(
                    "%s create net route-domain %s { id %s vlans add { %s } }\n"
                    % (SYSCMDS['tmsh'], link['route_domain'],
                       link['route_domain'], link['net_name']))
        # write out L3 network configuration
        for n_link in resources['selfips']:
            selfip = resources['selfips'][n_link]
            net_script.write(
                "%s create net self %s address %s/%s vlan %s allow-service all\n"
                %
                (SYSCMDS['tmsh'], selfip['selfip_name'], selfip['ip_address'],
                 selfip['netmask'], selfip['net_name']))

        for n_link in resources['routes']:
            for route in resources['routes'][n_link]:
                if not route['exclude']:
                    net_script.write(
                        "%s create net route %s network %s/%s gw %s\n" %
                        (SYSCMDS['tmsh'], route['route_name'],
                         route['network'], route['netmask'], route['gateway']))
        net_script.write("%s 'networking configured'\n" % SYSCMDS['echo'])


def creat_services_init_script(resources):
    """Create the initialization script for services configurations"""
    LOG.debug('writing out services initialization script')
    services_onboard_script = TMSH_CMD_FILE_DIR + '/003_services_setup.sh'
    if os.path.isfile(services_onboard_script):
        bigiq_onboard_utils.del_file(services_onboard_script)
    with open(services_onboard_script, 'w') as services_script:
        services = resources['services']
        services_script.write(
            "%s modify sys global-settings hostname %s.%s\n" %
            (SYSCMDS['tmsh'], services['hostname'], services['domainname']))
        services_script.write(
            "%s modify sys management-dhcp sys-mgmt-dhcp-config request-options delete { host-name }\n"
            % SYSCMDS['tmsh'])
        services_script.write(
            "%s modify sys dns search replace-all-with { %s }\n" %
            (SYSCMDS['tmsh'], services['domainname']))
        services_script.write(
            "%s modify sys dns name-servers replace-all-with { %s }\n" %
            (SYSCMDS['tmsh'], " ".join(services['dns_services'])))
        services_script.write(
            "%s modify sys management-dhcp sys-mgmt-dhcp-config request-options delete { domain-name-servers domain-name }\n"
            % SYSCMDS['tmsh'])
        services_script.write("%s modify sys ntp timezone %s\n" %
                              (SYSCMDS['tmsh'], DEFAULT_TIMEZONE))
        services_script.write(
            "%s modify sys ntp servers replace-all-with { %s }\n" %
            (SYSCMDS['tmsh'], " ".join(services['ntp_services'])))
        services_script.write(
            "%s modify sys management-dhcp sys-mgmt-dhcp-config request-options delete { ntp-servers }\n"
            % SYSCMDS['tmsh'])
        services_script.write("%s 'services configured'\n" % SYSCMDS['echo'])


def create_bigiq_init_script(resources, license_key, node_type):
    """Create the initialization script for BIG-IQ configurations"""
    LOG.debug('writing out BIG-IQ initialization script')
    sync_onboard_script = TMSH_CMD_FILE_DIR + '/004_device_discovery_setup.sh'
    if os.path.isfile(sync_onboard_script):
        bigiq_onboard_utils.del_file(sync_onboard_script)
    with open(sync_onboard_script, 'w') as cmi_script:
        cmi_script.write("cd %s\n" % ANSIBLE_PLAYBOOK_DIR)
        cmi_script.write("%s %s\n" %
                         (SYSCMDS['ansible-playbook'], ANSIBLE_PLAYBOOK))
    with open(ANSIBLE_VAR_FILE, 'w') as ansible_vars:
        ansible_vars.write('---\n\n')
        if license_key:
            ansible_vars.write('license_key: %s\n' % license_key)
        ansible_vars.write('node_type: %s\n' % node_type)
        ansible_vars.write('device_discovery_interface: %s\n' %
                           resources['device_discovery_interface'])
        ansible_vars.write('device_discovery_address: %s\n' %
                           resources['device_discovery_address'])
    return resources


def create_post_onboard_script(post_onboard_commands):
    """Create the post onboard command script"""
    if post_onboard_commands:
        LOG.debug('writing out post onboard commands script')
        post_onboard_commands_script = POST_ONBOARD_CMD_FILE_DIR + \
            '/001_post_onboard_commands.sh'
        if os.path.isfile(post_onboard_commands_script):
            bigiq_onboard_utils.del_file(post_onboard_commands_script)
        with open(post_onboard_commands_script, 'w') as pob_script:
            pob_script.write("#!/bin/bash\n")
            pob_script.write(
                "%s 'starting post onboarding commands provisioning'\n\n" %
                SYSCMDS['echo'])
            pob_script.write("cmds=(\n")
            for cmd in post_onboard_commands:
                pob_script.write("\"%s\"\n" % cmd.replace('"', r'\"'))
            pob_script.write(")\n\n")
            pob_script.write("for (( i = 0; i < ${#cmds[@]} ; i++ )); do\n")
            pob_script.write("    %s \"Running: ${cmds[$i]}\"\n" %
                             SYSCMDS['echo'])
            pob_script.write("    eval \"${cmds[$i]}\"\n")
            pob_script.write("    if [ $? -eq 1 ]; then\n")
            pob_script.write(
                "        %s \"Command: ${cmds[$i]} Failed. Stopping execution of any further commands.\"\n"
                % SYSCMDS['echo'])
            pob_script.write("        exit 1\n")
            pob_script.write("    fi\n")
            pob_script.write("done\n\n")


def create_onboard_artifacts(resources,
                             license_key,
                             node_type,
                             post_onboard_commands=None):
    """Generates all needed onboarding artifacts from metadata or the environment"""
    create_mgmt_init_script(resources)
    create_tmm_net_init_script(resources)
    creat_services_init_script(resources)
    create_bigiq_init_script(resources, license_key, node_type)
    create_post_onboard_script(post_onboard_commands)


def create_onboard():
    """Creates the initialization script for all tasks"""
    LOG.debug('writing out pre declaration onboard initialization script')
    onboard_script = TMSH_CMD_FILE_DIR + '/onboard.sh'
    if os.path.isfile(onboard_script):
        bigiq_onboard_utils.del_file(onboard_script)
    script_files = os.listdir(TMSH_CMD_FILE_DIR)
    script_files.sort()
    with open(onboard_script, 'w') as obs:
        obs.write("#!/bin/bash\n\n")
        obs.write("function check_mcpd_up() {\n")
        obs.write("    checks=0\n")
        obs.write("    while [ $checks -lt 120 ]; do\n")
        obs.write(
            "        if %s -a show sys mcp-state field-fmt 2> /dev/null | %s -q running; then\n"
            % (SYSCMDS['tmsh'], SYSCMDS['grep']))
        obs.write("            break\n")
        obs.write("        fi\n")
        obs.write("        %s 'waiting for mcpd to reach running state'\n" %
                  SYSCMDS['echo'])
        obs.write("        let checks=checks+1\n")
        obs.write("        %s 10\n" % SYSCMDS['sleep'])
        obs.write("    done\n")
        obs.write("}\n\n")
        obs.write("function exec_phases() {\n")
        for script_file in script_files:
            obs.write("    /bin/bash %s/%s\n" %
                      (TMSH_CMD_FILE_DIR, script_file))
        obs.write("    %s 1 > %s\n" %
                  (SYSCMDS['echo'], ONBOARD_COMPLETE_FLAG_FILE))
        obs.write("}\n\n")
        obs.write("check_mcpd_up\n")
        obs.write("exec_phases\n")
        obs.write("check_mcpd_up\n")
        obs.write("%s save sys config base\n" % SYSCMDS['tmsh'])
        obs.write("check_mcpd_up\n")
    os.chmod(onboard_script, 0775)


def create_post_onboard():
    """Creates the initialization script for all post onboarding scripts"""
    LOG.debug('writing out post onboard initialization script')
    onboard_script = POST_ONBOARD_CMD_FILE_DIR + '/onboard.sh'
    if os.path.isfile(onboard_script):
        bigiq_onboard_utils.del_file(onboard_script)
    script_files = os.listdir(POST_ONBOARD_CMD_FILE_DIR)
    script_files.sort()
    with open(onboard_script, 'w') as obs:
        obs.write("#!/bin/bash\n\n")
        obs.write("function check_mcpd_up() {\n")
        obs.write("    checks=0\n")
        obs.write("    while [ $checks -lt 120 ]; do\n")
        obs.write(
            "        if %s -a show sys mcp-state field-fmt 2> /dev/null | %s -q running; then\n"
            % (SYSCMDS['tmsh'], SYSCMDS['grep']))
        obs.write("            break\n")
        obs.write("        fi\n")
        obs.write("        %s 'waiting for mcpd to reach running state'\n" %
                  SYSCMDS['echo'])
        obs.write("        let checks=checks+1\n")
        obs.write("        %s 10\n" % SYSCMDS['sleep'])
        obs.write("    done\n")
        obs.write("}\n\n")
        obs.write("function exec_phases() {\n")
        for script_file in script_files:
            obs.write("    /bin/bash %s/%s\n" %
                      (POST_ONBOARD_CMD_FILE_DIR, script_file))
        obs.write("    %s 1 > %s\n" %
                  (SYSCMDS['echo'], POST_ONBOARD_FLAG_FILE))
        obs.write("}\n\n")
        obs.write("check_mcpd_up\n")
        obs.write("exec_phases\n")
    os.chmod(onboard_script, 0775)


def is_startup_injected(script_name):
    """ check if script is injected into /config/startup """
    injected_already = subprocess.Popen(
        "%s /config/startup | %s " + script_name + " | %s -l" %
        (SYSCMDS['cat'], SYSCMDS['grep'], SYSCMDS['wc']),
        stdout=subprocess.PIPE,
        shell=True).communicate()[0].replace('\n', '')
    if injected_already == '0':
        return False
    return True


def run_post_onboard_commands():
    """ run post onboard commands """
    post_onboard_script = POST_ONBOARD_CMD_FILE_DIR + '/onboard.sh'
    with open(LOG_FILE, 'a+') as onboardlog:
        LOG.info('running post onboard script')
        subprocess.call(
            [SYSCMDS['nohup'], 'sh', '-c', post_onboard_script, '&'],
            stdout=onboardlog,
            stderr=onboardlog)
        end_time = time.time() + ONBOARD_TIMEOUT
        while (end_time - time.time()) > 0:
            if not os.path.exists(POST_ONBOARD_FLAG_FILE):
                time.sleep(1)
            else:
                end_time = 0
        if os.path.exists(POST_ONBOARD_FLAG_FILE):
            LOG.error('post onboard commands did not complete properly')
            return False
        return True


def onboard(post_onboard_enabled, phone_home_url, phone_home_url_verify_tls,
            phone_home_cli):
    """Implements the onboarding business logic"""
    # initialize onboarding tasks
    onboard_status = ERROR
    onboard_script = TMSH_CMD_FILE_DIR + '/onboard.sh'
    with open(LOG_FILE, 'a+') as onboardlog:
        LOG.info('running onboarding scripts')
        subprocess.call([SYSCMDS['nohup'], 'sh', '-c', onboard_script, '&'],
                        stdout=onboardlog,
                        stderr=onboardlog)
    end_time = time.time() + ONBOARD_TIMEOUT
    while (end_time - time.time()) > 0:
        if not os.path.exists(ONBOARD_COMPLETE_FLAG_FILE):
            time.sleep(1)
        else:
            end_time = 0
        onboard_status = SUCCESS
    if onboard_status == SUCCESS:
        if post_onboard_enabled:
            if not run_post_onboard_commands():
                onboard_status = ERROR
                LOG.error('post onboarding did not complete')
    else:
        onboard_status = ERROR
        LOG.error('onboarding configuration did not complete')
    if phone_home_url:
        bigiq_onboard_utils.phone_home(phone_home_url, onboard_status,
                                       phone_home_url_verify_tls)
    if phone_home_cli and onboard_status == SUCCESS:
        bigiq_onboard_utils.run_cmd(phone_home_cli)
    LOG.info('onboarding ended with status: %s', onboard_status)


def clean():
    """Remove any onboarding artifacts"""
    if REMOVE_METADATA_FILES:
        if os.path.isfile(NETWORK_DATA_FILE):
            bigiq_onboard_utils.del_file(NETWORK_DATA_FILE)
        if os.path.isfile(META_DATA_FILE):
            bigiq_onboard_utils.del_file(META_DATA_FILE)
    bigiq_onboard_utils.clean()


def handle(name, userdata, cloud, log, args):
    """Cloud-init processing function"""
    tag = MODULE_NAME
    enabled = False
    if tag in userdata:
        try:
            enabled = bool(userdata[tag]['enabled'])
        except Exception:
            LOG.error('%s missing enabled attribute', tag)
            return
    if enabled:
        keys = []
        if "ssh_authorized_keys" in userdata:
            cfgkeys = userdata["ssh_authorized_keys"]
            keys.extend(cfgkeys)
        rd_enabled = True
        if 'rd_enabled' in userdata[tag]:
            rd_enabled = bool(userdata[tag]['rd_enabled'])
        default_route_interface = None
        if 'default_route_interface' in userdata[tag]:
            default_route_interface = str(
                userdata[tag]['default_route_interface'])
        device_discovery_interface = None
        if 'device_discovery_interface' in userdata[tag]:
            device_discovery_interface = str(
                userdata[tag]['device_discovery_interface'])
        inject_routes = True
        dhcp_timeout = 120
        if 'dhcp_timeout' in userdata[tag]:
            dhcp_timeout = int(userdata[tag]['dhcp_timeout'])
        if 'inject_routes' in userdata[tag]:
            inject_routes = bool(userdata[tag]['inject_routes'])
        license_key = None
        if 'license_key' in userdata[tag]:
            license_key = userdata[tag]['license_key']
        node_type = 'cm'
        if 'node_type' in userdata[tag]:
            node_type = userdata[tag]['node_type']
        post_onboard_enabled = False
        if 'post_onboard_enabled' in userdata[tag]:
            post_onboard_enabled = bool(userdata[tag]['post_onboard_enabled'])
        post_onboard_commands = []
        if 'post_onboard_commands' in userdata[tag]:
            post_onboard_commands = userdata[tag]['post_onboard_commands']
        # find configdrive, create configurations, deployment scripts, and deploy
        inject_public_ssh_keys(keys)
        if 'chpasswd' in userdata and 'list' in userdata['chpasswd']:
            for user in userdata['chpasswd']['list'].splitlines():
                parts = user.split(':')
                if len(parts) > 1:
                    bigiq_onboard_utils.set_password(parts[0].strip(),
                                                     parts[1].strip())
        resources = resolve_resources(rd_enabled, default_route_interface,
                                      device_discovery_interface,
                                      inject_routes, dhcp_timeout)
        LOG.debug('resolved config resources: %s', resources)
        create_onboard_artifacts(resources, license_key, node_type,
                                 post_onboard_commands)
        create_onboard()
        create_post_onboard()
        phone_home_url = None
        if 'phone_home_url' in userdata[tag]:
            phone_home_url = userdata[tag]['phone_home_url']

        phone_home_url_verify_tls = True
        if 'phone_home_url_verify_tls' in userdata[tag]:
            phone_home_url_verify_tls = userdata[tag][
                'phone_home_url_verify_tls']
        phone_home_cli = None
        if 'phone_home_cli' in userdata[tag]:
            phone_home_cli = userdata[tag]['phone_home_cli']
        try:
            onboard(post_onboard_enabled,
                    phone_home_url, phone_home_url_verify_tls,
                    phone_home_cli)
        except Exception as err:
            LOG.error("onboard exception - %s", err)
        try:
            bigiq_onboard_utils.clean()
        except Exception as err:
            LOG.error('onboard cleanup exception - %s', err)


if __name__ == "__main__":
    # Running the cloud-init module from the CLI python interpreter
    bigiq_onboard_utils.onboard_configdrive()
    USERDATA_FILE = '/opt/cloud/instance/user-data.txt'
    USERDATA_CONFIG = {MODULE_NAME: {'enabled': True}}
    if os.path.exists(USERDATA_FILE):
        USERDATA_CONFIG = bigiq_onboard_utils.read_conf(USERDATA_FILE)
    handle(MODULE_NAME, USERDATA_CONFIG, None, logging, [])
