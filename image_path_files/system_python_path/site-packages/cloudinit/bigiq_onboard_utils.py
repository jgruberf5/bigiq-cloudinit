# coding=utf-8
# pylint: disable=broad-except
# Copyright (c) 2016-2018, F5 Networks, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
This module supplies general onboarding utility functions
"""
import json
import logging
import os
import subprocess
import urlparse
import socket
import time
import requests
import yaml
import shutil
import StringIO

from errno import ENOENT, ENOEXEC

LOG_FILE = '/var/log/f5-cloudinit.log'

OUT_DIR = '/var/lib/cloud'

MGMT_DHCP_TIMEOUT = 600
MCPD_TIMEOUT = 600
PROCESS_KILL_DELAY = 2
BIGSTART_DELAY = 5
ICONTROL_TIMEOUT = 600
URL_TIMEOUT = 600

OUT_DIR = '/var/lib/cloud/'

MGMT_DHCP_LEASE_FILE = '/var/lib/dhclient/dhclient.leases'

DHCP_LEASE_DIR = OUT_DIR + '/dhclient'

SSH_KEY_FILE = '/root/.ssh/authorized_keys'
DEFAULT_DNS_SERVERS = ['8.8.8.8', '8.8.4.4']
DEFAULT_NTP_SERVERS = ['0.pool.ntp.org', '1.pool.ntp.org']
DEFAULT_TIMEZONE = 'UTC'
DEFAULT_DISCOVERY_INTERFACE = '1.1'

REMOVE_DHCP_LEASE_FILES = False

HOSTNAME_SET = False
NETWORKS_CONFIGURED = False


def touch_file(logfile, times=None):
    """Touch file if needed"""
    if not os.path.isfile(logfile):
        if not os.path.exists(os.path.dirname(logfile)):
            os.makedirs(os.path.dirname(logfile))
        with open(logfile, 'a'):
            os.utime(logfile, times)


touch_file(LOG_FILE)

LOG = logging.getLogger(__name__)
LOG.setLevel(logging.DEBUG)
FORMATTER = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
LOGFILE = logging.FileHandler(LOG_FILE)
LOGFILE.setLevel(logging.DEBUG)
LOGFILE.setFormatter(FORMATTER)
LOG.addHandler(LOGFILE)


def inject_public_ssh_keys(keys):
    """Injects discovered and metadata supplied SSH keys into the root account"""
    with open(SSH_KEY_FILE, 'a+') as keyfile:
        for k in keys:
            keyfile.write(k + '\n')


def is_v6(address):
    """Determines if the supplied address is a valid IPv6 address"""
    try:
        socket.inet_pton(socket.AF_INET6, address)
        return True
    except socket.error:
        return False


def is_v4(address):
    """Determines if the supplied address is a valid IPv4 address"""
    try:
        socket.inet_pton(socket.AF_INET, address)
        return True
    except socket.error:
        return False


def is_mgmt_ip():
    """Test if the eth0 interface has an IP address assigned"""
    fnull = open(os.devnull, 'w')
    mgmt_ip = subprocess.Popen(
        "ip addr show eth0 | grep '^\\s*inet '| grep -v 169.254 | wc -l",
        stdout=subprocess.PIPE, stderr=fnull, shell=True
    ).communicate()[0].replace('\n', '')
    if int(mgmt_ip) == 1:
        return True
    mgmt_ip = subprocess.Popen(
        "ip addr show eth0 | grep '^\\s*inet6 '| grep -v fe80 | wc -l",
        stdout=subprocess.PIPE, shell=True
    ).communicate()[0].replace('\n', '')
    if int(mgmt_ip) == 1:
        return True
    return False


def get_mgmt_cidr():
    """Return the managment interface IP address in CIDR notation from tmsh"""
    fnull = open(os.devnull, 'w')
    mgmt_cidr = subprocess.Popen(
        "tmsh list sys management-ip one-line | cut -d' ' -f3",
        stdout=subprocess.PIPE, stderr=fnull, shell=True
    ).communicate()[0].replace('\n', '')
    return mgmt_cidr


def is_mgmt_default_gateway():
    """Test if the mgmt subnet has a default gateway"""
    fnull = open(os.devnull, 'w')
    mgmt_gw = subprocess.Popen(
        "route -n | grep '^0.0.0.0'| grep eth0 | wc -l",
        stdout=subprocess.PIPE, stderr=fnull, shell=True
    ).communicate()[0].replace('\n', '')
    if int(mgmt_gw) == 1:
        return True
    return False


def get_tmos_version():
    """Get the TMOS version string"""
    fnull = open(os.devnull, 'w')
    version = subprocess.Popen(
        "cat /VERSION | grep -i sequence | cut -d':' -f2 | tr '[A-Z]' '[a-z]' | tr -d '[:space:]'",
        stdout=subprocess.PIPE, stderr=fnull, shell=True
    ).communicate()[0].replace('\n', '')
    return version


def get_tmos_product():
    """Get the TMOS product string"""
    fnull = open(os.devnull, 'w')
    product = subprocess.Popen(
        "tmsh show sys version | grep Product | awk '{print $NF}'",
        stdout=subprocess.PIPE, stderr=fnull, shell=True
    ).communicate()[0].replace('\n', '')
    return product


def get_dmi_uuid():
    """Get the system UUID from DMI"""
    fnull = open(os.devnull, 'w')
    uuid = subprocess.Popen(
        "dmidecode | grep -i UUID | cut -d':' -f2 | tr '[A-Z]' '[a-z]' | tr -d '[:space:]'",
        stdout=subprocess.PIPE, stderr=fnull, shell=True
    ).communicate()[0].replace('\n', '')
    return uuid


def get_hostname():
    """Get the system hostname"""
    return socket.gethostname()


def run_cmd(cmd):
    """Run a CLI command and return its output"""
    fnull = open(os.devnull, 'w')
    cmd_stdout = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE, stderr=fnull, shell=True
    ).communicate()[0].replace('\n', '')
    LOG.debug('running command %s produced %s', cmd, cmd_stdout)
    return cmd_stdout


def wait_for_mgmt_dhcp(timeout=None):
    """Blocks until the mgmt DHCP lease file is present"""
    if not timeout:
        timeout = MGMT_DHCP_TIMEOUT
    end_time = time.time() + timeout
    while (end_time - time.time()) > 0:
        if os.path.isfile(MGMT_DHCP_LEASE_FILE):
            return True
        time.sleep(1)
    return False


def is_mcpd():
    """Determines if the TMOS master control process is running"""
    fnull = open(os.devnull, 'w')
    running = subprocess.Popen(
        "tmsh -a show sys mcp-state field-fmt | grep running | wc -l",
        stdout=subprocess.PIPE, stderr=fnull, shell=True
    ).communicate()[0].replace('\n', '')
    if int(running) == 1:
        return True
    return False


def wait_for_mcpd(timeout=None):
    """Blocks until the TMOS master control process is running"""
    if not timeout:
        timeout = MCPD_TIMEOUT
    end_time = time.time() + timeout
    while (end_time - time.time()) > 0:
        if is_mcpd():
            return True
        time.sleep(1)
    LOG.error('mcpd did not reach tunning state in %s seconds', timeout)
    return False


def is_tmm():
    """Determines if the TMOS dataplane microkernels are running"""
    tmm_running = int(subprocess.Popen("ps -ef|grep /usr/bin/tmm|grep -v grep|wc -l| tr -d ';\n'",
                                       stdout=subprocess.PIPE, shell=True).communicate()[0])
    if tmm_running == 1:
        return True
    return False


def force_tmm_down():
    """Forces all TMOS dataplane microkernels down"""
    fnull = open(os.devnull, 'w')
    subprocess.call(['/bin/pkill', 'tmm'], stdout=fnull, stderr=fnull)
    subprocess.call(['/bin/bigstart', 'stop', 'tmm'],
                    stdout=fnull, stderr=fnull)
    subprocess.call(['/bin/pkill', 'tmm'], stdout=fnull, stderr=fnull)
    time.sleep(PROCESS_KILL_DELAY)


def stop_tmm():
    """Stops TMOS dataplane microkernels"""
    fnull = open(os.devnull, 'w')
    subprocess.call(['/bin/bigstart', 'stop', 'tmm'],
                    stdout=fnull, stderr=fnull)
    time.sleep(BIGSTART_DELAY)


def start_tmm():
    """Starts TMOS dataplane microkernels"""
    fnull = open(os.devnull, 'w')
    subprocess.call(['/bin/bigstart', 'start', 'tmm'],
                    stdout=fnull, stderr=fnull)
    time.sleep(BIGSTART_DELAY)


def bigstart_restart(service_name=None):
    """Restart a service with bigstart"""
    fnull = open(os.devnull, 'w')
    if not service_name:
        service_name = ''
    subprocess.call(['/bin/bigstart', 'resstart', service_name],
                    stdout=fnull, stderr=fnull)
    time.sleep(BIGSTART_DELAY)


def is_icontrol():
    """Determines if the TMOS control plane iControl REST service is running"""
    try:
        return requests.get(
            'http://localhost:8100/shared/echo',
            auth=('admin', '')
        ).json()['stage'] == 'STARTED'
    except Exception:
        return False


def wait_for_icontrol(timeout=None):
    """Blocks until the TMOS control plane iControl REST service is running"""
    if not timeout:
        timeout = ICONTROL_TIMEOUT
    end_time = time.time() + timeout
    while (end_time - time.time()) > 0:
        if is_icontrol():
            return True
        time.sleep(1)
    LOG.error(
        'iControl REST services could not be reached after %s seconds', timeout)
    return False


def is_rest_worker(workerpath):
    """Determines if the TMOS control plane iControl REST worker path exists"""
    try:
        return requests.get(
            'http://localhost:8100' + workerpath,
            auth=('admin', '')
        ).status_code != 404
    except Exception:
        return False


def wait_for_rest_worker(workerpath, timeout=None):
    """Blocks until the TMOS control plane iControl REST worker path exists"""
    task_url = 'http://localhost:8100' + workerpath
    if not timeout:
        timeout = ICONTROL_TIMEOUT
    end_time = time.time() + timeout
    while (end_time - time.time()) > 0:
        try:
            response = requests.get(task_url, auth=('admin', ''))
            if response.status_code < 400:
                return True
        except Exception:
            return False
        time.sleep(1)
    LOG.error('iControl REST worker %s could not be reached after %s seconds',
              workerpath, timeout)
    return False


def is_url(monitor_url, status_code=None):
    """Determins if the URL is reachable and optionally returns a status code"""
    try:
        response = requests.get(monitor_url)
        LOG.debug('URL %s status %s', monitor_url, response.status_code)
        if status_code:
            if response.status_code == status_code:
                return True
        return True
    except Exception as ex:
        LOG.error('URL %s exception %s', monitor_url, ex)
        return False
    return False


def wait_for_url(monitor_url, status_code=None, timeout=None):
    """Blocks until the URL is availale"""
    if not timeout:
        timeout = URL_TIMEOUT
    end_time = time.time() + timeout
    while (end_time - time.time()) > 0:
        if is_url(monitor_url, status_code):
            return True
        time.sleep(1)
    LOG.error('URL %s could not be reached after %s seconds',
              monitor_url, timeout)
    return False


def dhcp_lease_dir_exists():
    """Ensures DHCP lease file copy directory exists"""
    if not os.path.isdir(DHCP_LEASE_DIR):
        os.makedirs(DHCP_LEASE_DIR)


def make_dhcp4_request(interface, timeout=120):
    """Makes DHCPv4 queries out a linux link device"""
    dhcp_lease_dir_exists()
    tmp_conf_file = DHCP_LEASE_DIR + '/dhclient.conf'
    lease_file = DHCP_LEASE_DIR + '/' + interface + '.lease'
    tmp_lease_file = '/tmp/' + interface + '.lease'
    fnull = open(os.devnull, 'w')
    dhclient_cf = open(tmp_conf_file, 'w')
    dhclient_cf.write(
        "\nrequest subnet-mask, broadcast-address, time-offset, routers,\n")
    dhclient_cf.write(
        "        domain-name, domain-name-servers, domain-search, host-name,\n")
    dhclient_cf.write(
        "        root-path, interface-mtu, classless-static-routes;\n")
    dhclient_cf.close()
    if os.path.isfile(lease_file):
        del_file(lease_file)
    subprocess.call(['/bin/pkill', 'dhclient'], stdout=fnull)
    subprocess.call(['/sbin/dhclient',
                     '-lf',
                     tmp_lease_file,
                     '-cf',
                     tmp_conf_file,
                     '-1',
                     '-timeout',
                     str(timeout),
                     '-pf',
                     '/tmp/dhclient.' + interface + '.pid',
                     '-sf',
                     '/bin/echo',
                     interface], stdout=fnull)
    if os.path.getsize(tmp_lease_file) > 0:
        copy(tmp_lease_file, lease_file)
        subprocess.call(['/bin/pkill', 'dhclient'], stdout=fnull)
        del_file('/tmp/dhclient.' + interface + '.pid')
        del_file(tmp_lease_file)
        return True
    else:
        subprocess.call(['/bin/pkill', 'dhclient'], stdout=fnull)
        del_file('/tmp/dhclient.' + interface + '.pid')
        del_file(tmp_lease_file)
    return False


def process_dhcp4_lease(interface, return_options=None):
    """Parses dhclient v4 lease file format for metadata"""
    if not return_options:
        return_options = ['subnet-mask',
                          'routers',
                          'domain-name-servers',
                          'interface-mtu',
                          'classless-static-routes',
                          'host-name',
                          'domain-name']
    return_data = {}

    lease_file = DHCP_LEASE_DIR + '/' + interface + '.lease'
    if os.path.isfile(interface):
        lease_file = interface

    for line in open(lease_file):
        if 'fixed-address' not in return_data and "fixed-address" in line:
            # format: fixed-address 1.1.1.110;
            test_fixed_address = 'fixed-address '
            lidx = line.index(test_fixed_address)
            return_data['fixed-address'] = \
                line[lidx + len(test_fixed_address):].replace(';\n', '')
        for option in return_options:
            test_option = option + ' '
            if (option not in return_data) and (test_option in line):
                # format: option routers 1.1.1.1;
                lidx = line.index(test_option)
                return_data[option] = \
                    line[lidx + len(test_option):].replace(
                        ';\n', '').replace('"', '').replace("'", '')
    return return_data


def process_dhcp4_routes(static_routes):
    """Processes dhclient v4 static routes metadata"""
    dhcp_routes = []
    if static_routes:
        static_route_list = static_routes.split(',')
        for static_route in static_route_list:
            rap = static_route.split(' ')
            route = process_dhcp4_route(rap[0], rap[1])
            if route:
                dhcp_routes.append(route)
    return dhcp_routes


def process_dhcp4_route(static_route, gateway):
    """Parse single dhclient v4 route entry into a dictionary"""
    if not static_route == '0':
        route = {}
        route['network'] = static_route[static_route.find('.') + 1:]
        if len(route['network']) == 3:
            route['network'] = route['network'] + '.0.0.0'
        if route['network'].find('.') > 0:
            dots = route['network'].count('.')
            if dots == 1:
                route['network'] = route['network'] + '.0.0'
            if dots == 2:
                route['network'] = route['network'] + '.0'
        route['netmask'] = static_route[0:static_route.find('.')]
        route['gateway'] = gateway
        route['route_name'] = "route_%s_%s" % (
            route['network'], route['netmask'])
        route['route_name'] = route['route_name'].replace(
            '.', '_').replace(':', '_').replace('/', '_')
        # we don't forward to local or link local in a gateway
        if route['network'].startswith('127'):
            return None
        elif route['network'].startswith('169.254'):
            return None
        elif route['network'].lower().startswith('fe80'):
            return None
        return route
    return None


def ipv4_cidr_from_netmask(netmask):
    """Convert IPv4 netmask to CIDR bits"""
    return sum([bin(int(x)).count('1') for x in netmask.split('.')])


def wait_for_dns_resolution(fqdn, timeout=30):
    """Wait for DNS to resolve a required FQDN"""
    start = time.time()
    end = start + timeout
    while time.time() < end:
        try:
            socket.gethostbyname(fqdn)
            return True
        except socket.error:
            LOG.error('FQDN %s could not be resolved', fqdn)
            time.sleep(1)
    LOG.error('FQDN %s could not be resolved in %s seconds', fqdn, timeout)
    return False


def phone_home(phone_home_url=None, status='ERROR', verify_tls=True):
    """Issues a Phone Home web POST request with collected onboard data"""
    if phone_home_url:
        try:
            parsed_url = urlparse.urlparse(phone_home_url)
            fqdn = parsed_url.netloc
            if wait_for_dns_resolution(fqdn, 120):
                wait_for_icontrol(timeout=120)
                post_data = {}
                post_data['id'] = get_dmi_uuid()
                post_data['version'] = get_tmos_version()
                post_data['product'] = get_tmos_product()
                post_data['hostname'] = get_hostname()
                post_data['management'] = get_mgmt_cidr()
                post_data['status'] = status
                post_json = json.dumps(post_data)
                LOG.debug('POST %s - %s', phone_home_url, post_json)
                if verify_tls:
                    resp = requests.post(phone_home_url, data=post_json)
                    resp.raise_for_status()
                else:
                    resp = requests.post(
                        phone_home_url, data=post_json, verify=False)
                    resp.raise_for_status()
                return True
        except Exception as err:
            LOG.error("could not phone home: %s - %s", phone_home_url, err)
    return False


def clean():
    """Remove any onboarding artifacts"""
    if REMOVE_DHCP_LEASE_FILES:
        lease_files = os.listdir(DHCP_LEASE_DIR)
        for lease_file in lease_files:
            del_file("%s/%s" % (DHCP_LEASE_DIR, lease_file))


def get_configdrive_dev():
    """Get Device Name for a ConfigDrive"""
    fnull = open(os.devnull, 'w')
    dev = subprocess.Popen(
        "/sbin/blkid /dev/hd* | grep config-2 | cut -d':' -f1",
        stdout=subprocess.PIPE, stderr=fnull, shell=True
    ).communicate()[0].replace('\n', '')
    return dev


def mount_configdrive(dev, mountpath='/tmp/configdrive'):
    """Mount ConfigDrive"""
    if not os.path.exists(mountpath):
        os.makedirs(mountpath)
    fnull = open(os.devnull, 'w')
    mountout = subprocess.Popen(
        "/bin/mount %s %s" % (dev, mountpath),
        stdout=subprocess.PIPE, stderr=fnull, shell=True
    ).communicate()[0].replace('\n', '')
    return mountout


def ummount_configdrive(mountpath):
    """Unmount ConfigDrive"""
    time.sleep(3)
    fnull = open(os.devnull, 'w')
    umountout = subprocess.Popen(
        "/bin/umount %s" % mountpath,
        stdout=subprocess.PIPE, stderr=fnull, shell=True
    ).communicate()[0].replace('\n', '')
    return umountout


def onboard_configdrive():
    """Dicover ConfigDrive and Mount"""
    dev = get_configdrive_dev()
    if dev:
        systemid = get_dmi_uuid()
        userdata = '---'
        metadata = '{}'
        networkdata = '{}'
        mountpath = '/tmp/configdrive'
        mount_configdrive(dev, mountpath)
        userdatapath = "%s/openstack/latest/user_data" % mountpath
        metadatapath = "%s/openstack/latest/meta_data.json" % mountpath
        networkdatapath = "%s/openstack/latest/network_data.json" % mountpath
        if os.path.exists(userdatapath):
            f = open(userdatapath, "r")
            userdata = f.read()
            f.close()
        if os.path.exists(metadatapath):
            f = open(metadatapath, "r")
            metadata = f.read()
            f.close()
        if os.path.exists(networkdatapath):
            f = open(networkdatapath, "r")
            networkdata = f.read()
            f.close()
        create_cloudinit_resources(
            dev, systemid, userdata, metadata, networkdata)
        ummount_configdrive(mountpath)
        os.rmdir(mountpath)


def create_cloudinit_resources(dev, systemid, userdata, metadata, networkdata):
    """Copy ConfigDrive to CloudInit Locations"""
    if not os.path.exists('/opt/cloud/data'):
        os.makedirs('/opt/cloud/data')
    if not os.path.exists('/opt/cloud/handlers'):
        os.makedirs('/opt/cloud/handlers')
    if not os.path.exists('/opt/cloud/instances'):
        os.makedirs("/opt/cloud/instances/%s" % systemid)
        os.symlink("/opt/cloud/instances/%s" % systemid, '/opt/cloud/instance')
    if not os.path.exists('/opt/cloud/scripts'):
        os.makedirs('/opt/cloud/scripts/per-boot')
        os.makedirs('/opt/cloud/scripts/per-instance')
        os.makedirs('/opt/cloud/scripts/per-once')
        os.makedirs('/opt/cloud/seed')
        os.makedirs('/opt/cloud/sem')
    with open('/opt/cloud/data/instance-id', 'w') as instid:
        instid.write(systemid)
    with open('/opt/cloud/data/previous-instance-id', 'w') as instid:
        instid.write(systemid)
    with open('/opt/cloud/data/previous-datasource', 'w') as ds:
        ds.write(
            "DataSourceConfigDriveNet: DataSourceConfigDriveNet [net,ver=2][source=%s]" % dev)
    with open("/opt/cloud/instances/%s/datasource" % systemid, 'w') as ds:
        ds.write(
            "DataSourceConfigDriveNet: DataSourceConfigDriveNet [net,ver=2][source=%s]" % dev)
    with open("/opt/cloud/instances/%s/user-data.txt" % systemid, 'w') as ds:
        ds.write(userdata)
    with open("/opt/cloud/instances/%s/meta_data.json" % systemid, 'w') as ds:
        ds.write(metadata)
    with open("/opt/cloud/instances/%s/network_data.json" % systemid, 'w') as ds:
        ds.write(networkdata)


def set_hostname(hostname):
    if not HOSTNAME_SET:
        wait_for_mcpd()
        fnull = open(os.devnull, 'w')
        cmd = "tmsh modify sys global-settings hostname %s" % hostname
        sethostname = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=fnull, shell=True, 
        ).communicate()[0].replace('\n', '')
        cmd = "tmsh mv cm device $(tmsh list cm device | grep 'cm device' | cut -d ' ' -f3) %s" % hostname
        renamedevice = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=fnull, shell=True, 
        ).communicate()[0].replace('\n', '')
        HOSTNAME_SET = True


def del_file(path):
    LOG.debug("Attempting to remove %s", path)
    try:
        os.unlink(path)
    except OSError as e:
        if e.errno != ENOENT:
            raise e


def copy(src, dest):
    LOG.debug("Copying %s to %s", src, dest)
    shutil.copy(src, dest)


def read_conf(fname):
    try:
        return load_yaml(load_file(fname), default={})
    except IOError as e:
        if e.errno == ENOENT:
            return {}
        else:
            raise
        

def pipe_in_out(in_fh, out_fh, chunk_size=1024, chunk_cb=None):
    bytes_piped = 0
    while True:
        data = in_fh.read(chunk_size)
        if len(data) == 0:
            break
        else:
            out_fh.write(data)
            bytes_piped += len(data)
            if chunk_cb:
                chunk_cb(bytes_piped)
    out_fh.flush()
    return bytes_piped


def decode_binary(blob, encoding='utf-8'):
    if isinstance(blob, basestring):
        return blob
    return blob.decode(encoding)


def load_file(fname, read_cb=None, quiet=False, decode=True):
    LOG.debug("Reading from %s (quiet=%s)", fname, quiet)
    ofh = StringIO.StringIO
    try:
        with open(fname, 'rb') as ifh:
            pipe_in_out(ifh, ofh, chunk_cb=read_cb)
    except IOError as e:
        if not quiet:
            raise
        if e.errno != ENOENT:
            raise
    contents = ofh.getvalue()
    LOG.debug("Read %s bytes from %s", len(contents), fname)
    if decode:
        return decode_binary(contents)
    else:
        return contents


def load_yaml(blob, default=None, allowed=(dict,)):
    loaded = default
    blob = decode_binary(blob)
    try:
        LOG.debug("Attempting to load yaml from string "
                  "of length %s with allowed root types %s",
                  len(blob), allowed)
        converted = yaml.load(blob)
        if converted is None:
            LOG.debug("loaded blob returned None, returning default.")
            converted = default
        elif not isinstance(converted, allowed):
            raise TypeError("Yaml load only allows %s root types" % allowed)
        loaded = converted
    except (yaml.YAMLError, TypeError, ValueError) as e:
        msg = 'Failed loading yaml blob'
        mark = None
        if hasattr(e, 'context_mark') and getattr(e, 'context_mark'):
            mark = getattr(e, 'context_mark')
        elif hasattr(e, 'problem_mark') and getattr(e, 'problem_mark'):
            mark = getattr(e, 'problem_mark')
        if mark:
            msg += (
                '. Invalid format at line {line} column {col}: "{err}"'.format(
                    line=mark.line + 1, col=mark.column + 1, err=e))
        else:
            msg += '. {err}'.format(err=e)
        LOG.warning(msg)
    return loaded


def save_config():
    wait_for_mcpd()
    fnull = open(os.devnull, 'w')
    cmd = "tmsh save sys config"
    saveconfig = subprocess.Popen(
        cmd, stdout=subprocess.PIPE, stderr=fnull, shell=True, 
    ).communicate()[0].replace('\n', '')


def proceess_metadata():
    metadatapath = '/opt/cloud/instance/meta_data.json'
    if os.path.extsep(metadatapath):
        with open(metadatapath, 'r') as md:
            metadata = json.load(md)
            if 'hostname' in metadata:
                set_hostname(metadata['hostname'])
            if 'public_keys' in metadata:
                keys = []
                for keyname in metadata['public_keys'].keys():
                    keys.append(metadata['public_keys'][keyname])
                inject_public_ssh_keys(keys)
    networkdatapath = '/opt/cloud/instance/network_data.json'
